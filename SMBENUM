from pathlib import Path;
import getpass;
import tkinter as tk;
import tkinter.simpledialog;
import datetime;
import subprocess;
import re;
import pandas as pd;

#variables you MAY want to change
output_filetype = "csv";   #csv or txt -- txt will mimic smbmap output
ips = """
10.11.103.198
10.11.103.197
10.11.103.193
10.11.103.192
10.11.103.252
10.11.103.188
10.11.103.186
10.11.103.185
10.11.103.184
10.11.103.182
10.6.82.72
10.6.82.71
10.4.69.243
10.4.224.184
10.4.225.121
10.4.225.122
10.6.82.76
10.6.82.75
10.6.82.73
10.4.102.165
10.6.82.74
10.6.82.77
10.6.82.156
10.6.82.70
10.6.82.69
10.6.82.67
10.6.82.68
10.4.103.164
""".split();

#region init remaining, un interesting vars
#count for csv output
count = 0;

#location of smbmap script
smbmap = f'{Path(".")}/smbmap.py';

#where to output results
outputFile = Path(Path.home()/f'Downloads/smbmap_{datetime.datetime.now().strftime("%Y_%m_%d")}.{output_filetype}');

#credentials
racf = getpass.getuser();
root = tk.Tk().withdraw();
creds = tkinter.simpledialog.askstring( title='Password', prompt='Enter password: ', show='*' );
#creds='';
#endregion

#rename output file if it exists
if outputFile.exists():
    outputFile.rename(str(outputFile)+'.bak');

print("Enumerating through target list...\r\n\r\n");
for ip in ips:
    ip = ip.strip();

    p = subprocess.Popen([f'{smbmap} -u {racf} -p {creds} -d corp -H {ip}'], shell=True, stdout=subprocess.PIPE);
    (output, err) = p.communicate();

    #convert bytes to utf-8
    output = output.decode('utf-8');

    #check stdout for error identifier. stop script if detected
    if '[!]' in output:
        print(f"Error detected! Please check output below.\r\nStopping script to prevent account lockout\r\n\r\n{output}")
        break;

    if output_filetype == 'txt':
        #wait for smb script to finish
        #p_status = p.wait();

        print(output)
        #write output to file
        with open(outputFile, "a") as file:
            file.write(output);

    elif output_filetype == 'csv':
        hostfound = False;
        linegap = 0;
        hostname = ip = disk = permissions = comment = None;
        asset_pattern = r'.*IP:\s?((?:\d{1,3}\.?){4}\:\d*)\tName:\s?(\S*)';
        share_pattern = r'\t(.*)\t(.*)\t(.*)';

        print(f'\tTarget {count + 1} of {len(ips)}...');
        count += 1;

        #split stdout into lines
        for line in output.split('\n'):
            if not hostfound:
                matches = re.match(asset_pattern, line, re.IGNORECASE);
                if matches:
                    ip, hostname = matches.group(1).strip(), matches.group(2).strip();
                    hostfound = True;
                    continue;

            #ignore 2 lines after finding asset
            if hostfound and linegap < 2:
                linegap += 1;
                continue;

            #after host has been id'd and line gap skipped, parse data
            if linegap == 2:
                matches = re.match(share_pattern, line, re.IGNORECASE);
                if matches:
                    #disk,permissions,comment = matches.group(1).strip(), matches.group(2).strip(), matches.group(3).strip();

                    smbShare = pd.DataFrame(data={
                        "IP"          : ip,
                        "Name"        : hostname,
                        "Disk"        : matches.group(1).strip(),
                        "Permissions" : matches.group(2).strip(),
                        "Comment"     : matches.group(3).strip()
                    }, index=[0])

                    #print(smbShare.to_string(index=False))

                    #append output
                    with open(outputFile, 'a') as f:
                        smbShare.to_csv(f, index=False, mode='a', header=f.tell()==0)

                    continue
        #endregion

print(f'\r\n\r\nResults have been saved to {outputFile}');
